{"id":"../../node_modules/axios/lib/core/Axios.js","dependencies":[{"name":"D:\\learning-projects\\js\\natours\\package.json","includedInParent":true,"mtime":1738789525091},{"name":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\package.json","includedInParent":true,"mtime":1737806351315},{"name":"./../utils.js","loc":{"line":3,"column":18,"index":33},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\utils.js"},{"name":"../helpers/buildURL.js","loc":{"line":4,"column":21,"index":71},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\helpers\\buildURL.js"},{"name":"./InterceptorManager.js","loc":{"line":5,"column":31,"index":128},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\InterceptorManager.js"},{"name":"./dispatchRequest.js","loc":{"line":6,"column":28,"index":183},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\dispatchRequest.js"},{"name":"./mergeConfig.js","loc":{"line":7,"column":24,"index":231},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\mergeConfig.js"},{"name":"./buildFullPath.js","loc":{"line":8,"column":26,"index":277},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\buildFullPath.js"},{"name":"../helpers/validator.js","loc":{"line":9,"column":22,"index":321},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\helpers\\validator.js"},{"name":"./AxiosHeaders.js","loc":{"line":10,"column":25,"index":373},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\Axios.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\AxiosHeaders.js"}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _utils = _interopRequireDefault(require(\"./../utils.js\"));\nvar _buildURL = _interopRequireDefault(require(\"../helpers/buildURL.js\"));\nvar _InterceptorManager = _interopRequireDefault(require(\"./InterceptorManager.js\"));\nvar _dispatchRequest = _interopRequireDefault(require(\"./dispatchRequest.js\"));\nvar _mergeConfig = _interopRequireDefault(require(\"./mergeConfig.js\"));\nvar _buildFullPath = _interopRequireDefault(require(\"./buildFullPath.js\"));\nvar _validator = _interopRequireDefault(require(\"../helpers/validator.js\"));\nvar _AxiosHeaders = _interopRequireDefault(require(\"./AxiosHeaders.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst validators = _validator.default.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new _InterceptorManager.default(),\n      response: new _InterceptorManager.default()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack;\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n      throw err;\n    }\n  }\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n    config = (0, _mergeConfig.default)(this.defaults, config);\n    const {\n      transitional,\n      paramsSerializer,\n      headers\n    } = config;\n    if (transitional !== undefined) {\n      _validator.default.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n    if (paramsSerializer != null) {\n      if (_utils.default.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        };\n      } else {\n        _validator.default.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n    _validator.default.assertOptions(config, {\n      baseUrl: validators.spelling('baseURL'),\n      withXsrfToken: validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && _utils.default.merge(headers.common, headers[config.method]);\n    headers && _utils.default.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {\n      delete headers[method];\n    });\n    config.headers = _AxiosHeaders.default.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n    let promise;\n    let i = 0;\n    let len;\n    if (!synchronousRequestInterceptors) {\n      const chain = [_dispatchRequest.default.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n      promise = Promise.resolve(config);\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n      return promise;\n    }\n    len = requestInterceptorChain.length;\n    let newConfig = config;\n    i = 0;\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n    try {\n      promise = _dispatchRequest.default.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n    i = 0;\n    len = responseInterceptorChain.length;\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n    return promise;\n  }\n  getUri(config) {\n    config = (0, _mergeConfig.default)(this.defaults, config);\n    const fullPath = (0, _buildFullPath.default)(config.baseURL, config.url);\n    return (0, _buildURL.default)(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\n_utils.default.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request((0, _mergeConfig.default)(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n_utils.default.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request((0, _mergeConfig.default)(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n  Axios.prototype[method] = generateHTTPMethod();\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\nvar _default = exports.default = Axios;"},"sourceMaps":null,"error":null,"hash":"649d33ea06b9281b33e13939d9d15b37","cacheData":{"env":{}}}