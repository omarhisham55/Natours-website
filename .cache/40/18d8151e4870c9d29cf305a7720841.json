{"id":"../../node_modules/axios/lib/adapters/fetch.js","dependencies":[{"name":"D:\\learning-projects\\js\\natours\\package.json","includedInParent":true,"mtime":1738789525091},{"name":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\package.json","includedInParent":true,"mtime":1737806351315},{"name":"../platform/index.js","loc":{"line":1,"column":21,"index":21},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\platform\\index.js"},{"name":"../utils.js","loc":{"line":2,"column":18,"index":63},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\utils.js"},{"name":"../core/AxiosError.js","loc":{"line":3,"column":23,"index":101},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\AxiosError.js"},{"name":"../helpers/composeSignals.js","loc":{"line":4,"column":27,"index":153},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\helpers\\composeSignals.js"},{"name":"../helpers/trackStream.js","loc":{"line":5,"column":26,"index":211},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\helpers\\trackStream.js"},{"name":"../core/AxiosHeaders.js","loc":{"line":6,"column":25,"index":265},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\AxiosHeaders.js"},{"name":"../helpers/progressEventReducer.js","loc":{"line":7,"column":75,"index":367},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\helpers\\progressEventReducer.js"},{"name":"../helpers/resolveConfig.js","loc":{"line":8,"column":26,"index":431},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\helpers\\resolveConfig.js"},{"name":"../core/settle.js","loc":{"line":9,"column":19,"index":481},"parent":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"D:\\learning-projects\\js\\natours\\node_modules\\axios\\lib\\core\\settle.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _index = _interopRequireDefault(require(\"../platform/index.js\"));\nvar _utils = _interopRequireDefault(require(\"../utils.js\"));\nvar _AxiosError = _interopRequireDefault(require(\"../core/AxiosError.js\"));\nvar _composeSignals = _interopRequireDefault(require(\"../helpers/composeSignals.js\"));\nvar _trackStream = require(\"../helpers/trackStream.js\");\nvar _AxiosHeaders = _interopRequireDefault(require(\"../core/AxiosHeaders.js\"));\nvar _progressEventReducer = require(\"../helpers/progressEventReducer.js\");\nvar _resolveConfig = _interopRequireDefault(require(\"../helpers/resolveConfig.js\"));\nvar _settle = _interopRequireDefault(require(\"../core/settle.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Response(str).arrayBuffer()));\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false;\n  }\n};\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n  const hasContentType = new Request(_index.default.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    }\n  }).headers.has('Content-Type');\n  return duplexAccessed && !hasContentType;\n});\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst supportsResponseStream = isReadableStreamSupported && test(() => _utils.default.isReadableStream(new Response('').body));\nconst resolvers = {\n  stream: supportsResponseStream && (res => res.body)\n};\nisFetchSupported && (res => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = _utils.default.isFunction(res[type]) ? res => res[type]() : (_, config) => {\n      throw new _AxiosError.default(`Response type '${type}' is not supported`, _AxiosError.default.ERR_NOT_SUPPORT, config);\n    });\n  });\n})(new Response());\nconst getBodyLength = async body => {\n  if (body == null) {\n    return 0;\n  }\n  if (_utils.default.isBlob(body)) {\n    return body.size;\n  }\n  if (_utils.default.isSpecCompliantForm(body)) {\n    const _request = new Request(_index.default.origin, {\n      method: 'POST',\n      body\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n  if (_utils.default.isArrayBufferView(body) || _utils.default.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n  if (_utils.default.isURLSearchParams(body)) {\n    body = body + '';\n  }\n  if (_utils.default.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n};\nconst resolveBodyLength = async (headers, body) => {\n  const length = _utils.default.toFiniteNumber(headers.getContentLength());\n  return length == null ? getBodyLength(body) : length;\n};\nvar _default = exports.default = isFetchSupported && (async config => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = (0, _resolveConfig.default)(config);\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n  let composedSignal = (0, _composeSignals.default)([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n  let request;\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n    composedSignal.unsubscribe();\n  });\n  let requestContentLength;\n  try {\n    if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n      let contentTypeHeader;\n      if (_utils.default.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader);\n      }\n      if (_request.body) {\n        const [onProgress, flush] = (0, _progressEventReducer.progressEventDecorator)(requestContentLength, (0, _progressEventReducer.progressEventReducer)((0, _progressEventReducer.asyncDecorator)(onUploadProgress)));\n        data = (0, _trackStream.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n    if (!_utils.default.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'include' : 'omit';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = \"credentials\" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n    let response = await fetch(request);\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {\n      const options = {};\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n      const responseContentLength = _utils.default.toFiniteNumber(response.headers.get('content-length'));\n      const [onProgress, flush] = onDownloadProgress && (0, _progressEventReducer.progressEventDecorator)(responseContentLength, (0, _progressEventReducer.progressEventReducer)((0, _progressEventReducer.asyncDecorator)(onDownloadProgress), true)) || [];\n      response = new Response((0, _trackStream.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n        flush && flush();\n        unsubscribe && unsubscribe();\n      }), options);\n    }\n    responseType = responseType || 'text';\n    let responseData = await resolvers[_utils.default.findKey(resolvers, responseType) || 'text'](response, config);\n    !isStreamResponse && unsubscribe && unsubscribe();\n    return await new Promise((resolve, reject) => {\n      (0, _settle.default)(resolve, reject, {\n        data: responseData,\n        headers: _AxiosHeaders.default.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      });\n    });\n  } catch (err) {\n    unsubscribe && unsubscribe();\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(new _AxiosError.default('Network Error', _AxiosError.default.ERR_NETWORK, config, request), {\n        cause: err.cause || err\n      });\n    }\n    throw _AxiosError.default.from(err, err && err.code, config, request);\n  }\n});"},"sourceMaps":null,"error":null,"hash":"f12f51638c27937017d41cadf16bda40","cacheData":{"env":{}}}